"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-stacked-center-carousel";
exports.ids = ["vendor-chunks/react-stacked-center-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-stacked-center-carousel/dist/index.modern.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-stacked-center-carousel/dist/index.modern.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResponsiveContainer: () => (/* binding */ ResponsiveContainer),\n/* harmony export */   StackedCarousel: () => (/* binding */ StackedCarousel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_resize_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-resize-detector */ \"(ssr)/./node_modules/react-resize-detector/build/index.esm.js\");\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar StackedCarousel = /*#__PURE__*/function (_React$PureComponent) {\n  _inheritsLoose(StackedCarousel, _React$PureComponent);\n\n  function StackedCarousel(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this;\n\n    _this.validateProps = function () {\n      var _this$props = _this.props,\n          swipeSpeed = _this$props.swipeSpeed,\n          currentVisibleSlide = _this$props.currentVisibleSlide,\n          maxVisibleSlide = _this$props.maxVisibleSlide,\n          fadeDistance = _this$props.fadeDistance,\n          customScales = _this$props.customScales,\n          data = _this$props.data;\n\n      if (data.length < (maxVisibleSlide + 1) / 2) {\n        throw Error('you must have more than (maxVisibleSlide + 1) / 2 data item');\n      }\n\n      if (currentVisibleSlide && currentVisibleSlide % 2 !== 1 || maxVisibleSlide % 2 !== 1) {\n        throw Error('currentVisibleSlide or maxVisibleSlide must be an odd number');\n      }\n\n      if (currentVisibleSlide && currentVisibleSlide > maxVisibleSlide) {\n        throw Error('currentVisibleSlide must be smaller than maxVisibleSlide');\n      }\n\n      if (fadeDistance !== undefined) {\n        if (fadeDistance > 1 || fadeDistance < 0) {\n          throw Error('fadeDistance is a percentage value in the range of 0 - 1');\n        }\n      }\n\n      if (customScales && customScales.length !== (maxVisibleSlide + 3) / 2) {\n        throw Error('customScales must have lengh (maxVisibleSlide + 3) / 2');\n      }\n\n      if (swipeSpeed && (swipeSpeed > 0.99 || swipeSpeed < 0.01)) {\n        throw Error('swipeSpeed must have a value between 0.01 and 0.99');\n      }\n    };\n\n    _this.initializeProperties = function (constructor) {\n      if (constructor === void 0) {\n        constructor = false;\n      }\n\n      _this.validateProps();\n\n      var _this$props2 = _this.props,\n          carouselWidth = _this$props2.carouselWidth,\n          slideWidth = _this$props2.slideWidth,\n          currentVisibleDisplaySlide = _this$props2.currentVisibleSlide,\n          maxVisibleSlide = _this$props2.maxVisibleSlide;\n      var currentVisibleSlides = currentVisibleDisplaySlide || maxVisibleSlide;\n      var visibleSlidePerSide = (currentVisibleSlides - 1) / 2;\n      var slidePerSide = Math.max(visibleSlidePerSide + 1, 1);\n      var totalRenderCount = maxVisibleSlide + 2;\n      var renderedSlidePerSide = (maxVisibleSlide + 1) / 2;\n\n      var _this$calculateScaleA = _this.calculateScaleAndOffsets(slidePerSide),\n          offsets = _this$calculateScaleA.offsets,\n          scaledOffsets = _this$calculateScaleA.scaledOffsets,\n          scales = _this$calculateScaleA.scales;\n\n      var newRenderedSlides = constructor ? Array(totalRenderCount).fill(null) : _this.state.renderedSlides.filter(function (_ref) {\n        var slideIndex = _ref.slideIndex,\n            dataIndex = _ref.dataIndex;\n        return dataIndex === -1 || Math.abs(slideIndex) <= _this.slidePerSide;\n      });\n      var slideInfoMap = {};\n      var newCenterSlideRelativeIndex = constructor ? (totalRenderCount - 1) / 2 : newRenderedSlides.findIndex(function (_ref2) {\n        var slideIndex = _ref2.slideIndex;\n        return slideIndex === 0;\n      });\n      var newCenterDataIndex = constructor ? 0 : newRenderedSlides[newCenterSlideRelativeIndex].dataIndex;\n      var filledWidth = 0;\n      var centerPosition = carouselWidth / 2 - slideWidth / 2;\n\n      var _loop = function _loop(absIndex) {\n        var offset = offsets[absIndex];\n        var slideScale = scales[absIndex];\n        var currentOffSet = filledWidth + offset;\n        [-absIndex, absIndex].forEach(function (slideIndex) {\n          var relativeIndex = newCenterSlideRelativeIndex + slideIndex;\n          var position = slideIndex >= 0 ? currentOffSet : -currentOffSet;\n          var opacity = absIndex === slidePerSide ? 0 : 1;\n\n          var dataIndex = _this.modDataRange(newCenterDataIndex + slideIndex);\n\n          newRenderedSlides[relativeIndex] = {\n            dataIndex: dataIndex,\n            scale: slideScale,\n            position: position,\n            slideIndex: slideIndex,\n            opacity: opacity,\n            zIndex: renderedSlidePerSide - Math.abs(slideIndex),\n            key: constructor ? slideIndex : newRenderedSlides[relativeIndex].key\n          };\n          slideInfoMap[slideIndex] = {\n            position: position,\n            scale: slideScale,\n            opacity: opacity\n          };\n        });\n        if (absIndex !== 0) filledWidth += scaledOffsets[absIndex];\n      };\n\n      for (var absIndex = 0; absIndex <= slidePerSide; absIndex++) {\n        _loop(absIndex);\n      }\n\n      for (var i = -slidePerSide; i <= slidePerSide; i++) {\n        slideInfoMap[i].maxTransformDistance = {};\n        slideInfoMap[i].maxTransformScale = {};\n        slideInfoMap[i].maxTransformOpacity = {\n          left: i === -slidePerSide + 1 || i === slidePerSide ? 1 : 0,\n          right: i === -slidePerSide || i === slidePerSide - 1 ? 1 : 0\n        };\n        slideInfoMap[i].slideIndex = i;\n\n        if (i === -slidePerSide) {\n          slideInfoMap[i].maxTransformDistance.left = 0;\n          slideInfoMap[i].maxTransformScale.left = 0;\n        } else {\n          slideInfoMap[i].maxTransformDistance.left = slideInfoMap[i].position - slideInfoMap[i - 1].position;\n          slideInfoMap[i].maxTransformScale.left = Math.abs(slideInfoMap[i].scale - slideInfoMap[i - 1].scale);\n        }\n\n        if (i === slidePerSide) {\n          slideInfoMap[i].maxTransformDistance.right = 0;\n          slideInfoMap[i].maxTransformScale.right = 0;\n        } else {\n          slideInfoMap[i].maxTransformDistance.right = slideInfoMap[i + 1].position - slideInfoMap[i].position;\n          slideInfoMap[i].maxTransformScale.right = Math.abs(slideInfoMap[i + 1].scale - slideInfoMap[i].scale);\n        }\n      }\n\n      if (maxVisibleSlide > currentVisibleSlides) {\n        var maxRenderedSlidePerSide = (maxVisibleSlide + 1) / 2;\n        var currentSlidePerSide = slidePerSide;\n\n        for (var _i = currentSlidePerSide + 1; _i <= maxRenderedSlidePerSide; _i++) {\n          for (var direct = 1; direct >= 0; direct--) {\n            var insertIndex = newCenterSlideRelativeIndex + (direct === 1 ? _i : -_i);\n            var prevIndex = insertIndex + (direct === 1 ? -1 : 1);\n            var slideIndex = direct === 1 ? _i : -_i;\n            var scalePositionIndex = constructor ? prevIndex : insertIndex;\n            newRenderedSlides[insertIndex] = {\n              scale: newRenderedSlides[scalePositionIndex].scale,\n              position: newRenderedSlides[scalePositionIndex].position,\n              key: constructor ? -slideIndex : newRenderedSlides[insertIndex].key,\n              dataIndex: -1,\n              slideIndex: slideIndex,\n              opacity: 0,\n              zIndex: 0\n            };\n          }\n        }\n      }\n\n      var sortedSlideInfo = Object.values(slideInfoMap);\n      sortedSlideInfo.sort(function (slide1, slide2) {\n        return slide1.position - slide2.position;\n      });\n      return {\n        renderedSlides: newRenderedSlides,\n        centerSlideRelativeIndex: newCenterSlideRelativeIndex,\n        slideInfoMap: slideInfoMap,\n        slidePerSide: slidePerSide,\n        newRenderedSlides: newRenderedSlides,\n        sortedSlideInfo: sortedSlideInfo,\n        centerPosition: centerPosition,\n        renderedSlidePerSide: renderedSlidePerSide\n      };\n    };\n\n    _this.calculateScaleAndOffsets = function (slidePerSide) {\n      var _this$props3 = _this.props,\n          carouselWidth = _this$props3.carouselWidth,\n          slideWidth = _this$props3.slideWidth,\n          customScales = _this$props3.customScales,\n          fadeDistance = _this$props3.fadeDistance;\n      var availableSpace = carouselWidth / 2 - slideWidth / 2;\n      var scales = [1];\n      var scaledSlideWidths = [slideWidth];\n\n      for (var slide = 1; slide <= slidePerSide; slide++) {\n        var scale = customScales ? customScales[slide] : Math.pow(StackedCarousel.defaultScaleFactor, slide);\n        scales.push(scale);\n        scaledSlideWidths.push(slideWidth * scale);\n      }\n\n      var includedSlideWidths = scaledSlideWidths.slice(1);\n      var fillingSpace = availableSpace;\n\n      if (fadeDistance !== undefined) {\n        includedSlideWidths = scaledSlideWidths.slice(1, slidePerSide);\n        fillingSpace = availableSpace * (1 - fadeDistance);\n      }\n\n      var totalSlideWidth = includedSlideWidths.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n      var offSetPercentage = totalSlideWidth ? fillingSpace / totalSlideWidth : 0;\n      var scaledOffsets = [0];\n      var offsets = [0];\n\n      for (var _slide = 1; _slide <= slidePerSide; _slide++) {\n        var isCustomFade = fadeDistance !== undefined && _slide === slidePerSide;\n        var _scale = scales[_slide];\n        scaledOffsets[_slide] = isCustomFade ? fadeDistance * availableSpace : slideWidth * _scale * offSetPercentage;\n        offsets[_slide] = scaledOffsets[_slide] + slideWidth * ((1 - _scale) / 2);\n      }\n\n      return {\n        offsets: offsets,\n        scaledOffsets: scaledOffsets,\n        scales: scales\n      };\n    };\n\n    _this.getZIndex = function (slideIndex) {\n      return _this.renderedSlidePerSide - Math.abs(slideIndex);\n    };\n\n    _this.updateHeight = function () {\n      var height = _this.props.height;\n      if (height) return;\n\n      var _this$getSlideDOMInfo = _this.getSlideDOMInfo(0),\n          slideDOM = _this$getSlideDOMInfo.slideDOM;\n\n      var parsedHeight = parseInt(window.getComputedStyle(slideDOM).height);\n\n      if (parsedHeight !== _this.height) {\n        _this.height = parsedHeight;\n\n        _this.forceUpdate();\n      }\n    };\n\n    _this.modDataRange = function (n) {\n      var data = _this.props.data;\n      var m = data.length;\n      return (n % m + m) % m;\n    };\n\n    _this.debouncedClearInvisibleSlide = function () {\n      var transitionTime = _this.props.transitionTime;\n      clearTimeout(_this.clearSlideTimeout);\n      _this.clearSlideTimeout = setTimeout(_this.clearUselessSlide, transitionTime !== undefined ? transitionTime : StackedCarousel.defaultTransitionTime);\n    };\n\n    _this.clearUselessSlide = function () {\n      _this.addedSlide = 0;\n      var renderedSlides = _this.state.renderedSlides;\n      var newRenderedSlides = renderedSlides.filter(function (_ref3) {\n        var slideIndex = _ref3.slideIndex,\n            dataIndex = _ref3.dataIndex;\n        var absoluteSlideIndex = Math.abs(slideIndex);\n\n        if (absoluteSlideIndex <= _this.slidePerSide || dataIndex === -1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      _this.setState({\n        renderedSlides: newRenderedSlides\n      });\n    };\n\n    _this.safeGetSlideInfo = function (slideIndex) {\n      var positionIndex = slideIndex;\n\n      if (positionIndex > _this.slidePerSide) {\n        positionIndex = _this.slidePerSide;\n      } else if (positionIndex < -_this.slidePerSide) {\n        positionIndex = -_this.slidePerSide;\n      }\n\n      return _this.slideInfoMap[positionIndex];\n    };\n\n    _this.getInsertionInfo = function (steps) {\n      var newAddedSlideIndex = steps > 0 ? _this.slidePerSide - steps + 1 : -_this.slidePerSide - steps - 1;\n      var targetSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;\n\n      var requireMoreSlide = function requireMoreSlide(current, target) {\n        return steps > 0 ? current <= target : current >= target;\n      };\n\n      var updateCount = steps > 0 ? 1 : -1;\n      return {\n        newAddedSlideIndex: newAddedSlideIndex,\n        targetSlideIndex: targetSlideIndex,\n        requireMoreSlide: requireMoreSlide,\n        updateCount: updateCount\n      };\n    };\n\n    _this.moveCarousel = function (steps, disableSwipeRightState) {\n      if (disableSwipeRightState === void 0) {\n        disableSwipeRightState = false;\n      }\n\n      var renderedSlides = _this.state.renderedSlides;\n      var onActiveSlideChange = _this.props.onActiveSlideChange;\n      var newCenterDataIndex = 0;\n      var newSlides = renderedSlides.map(function (oldSlide) {\n        var slideIndex = oldSlide.slideIndex,\n            dataIndex = oldSlide.dataIndex;\n        if (dataIndex === -1) return oldSlide;\n        if (slideIndex === 0) newCenterDataIndex = _this.modDataRange(dataIndex + steps);\n        var newSlideIndex = slideIndex + -steps;\n\n        var slideInfo = _this.safeGetSlideInfo(newSlideIndex);\n\n        return _extends({}, oldSlide, {\n          slideIndex: newSlideIndex,\n          position: slideInfo.position,\n          scale: slideInfo.scale,\n          opacity: slideInfo.opacity,\n          zIndex: _this.getZIndex(newSlideIndex)\n        });\n      });\n\n      if (steps !== 0) {\n        (function () {\n          var maxSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;\n          _this.addedSlide += Math.abs(steps);\n\n          var insertionInfo = _this.getInsertionInfo(steps);\n\n          var newAddedSlideIndex = insertionInfo.newAddedSlideIndex;\n          var requireMoreSlide = insertionInfo.requireMoreSlide,\n              updateCount = insertionInfo.updateCount,\n              targetSlideIndex = insertionInfo.targetSlideIndex;\n\n          while (requireMoreSlide(newAddedSlideIndex, targetSlideIndex)) {\n            var slideAlreadyExist = newSlides.find(function (_ref4) {\n              var slideIndex = _ref4.slideIndex;\n              return slideIndex === newAddedSlideIndex;\n            });\n\n            if (!slideAlreadyExist) {\n              var insertPosition = newSlides.findIndex(function (_ref5) {\n                var slideIndex = _ref5.slideIndex,\n                    dataIndex = _ref5.dataIndex;\n                return slideIndex === newAddedSlideIndex - updateCount && dataIndex !== -1;\n              });\n              var _this$slideInfoMap$ma = _this.slideInfoMap[maxSlideIndex],\n                  scale = _this$slideInfoMap$ma.scale,\n                  position = _this$slideInfoMap$ma.position;\n\n              var insertDataIndex = _this.modDataRange(newSlides[insertPosition].dataIndex + updateCount);\n\n              _this.keyCount += 1;\n\n              var zIndex = _this.getZIndex(newAddedSlideIndex);\n\n              var insertSlide = {\n                scale: scale,\n                position: position,\n                opacity: 0,\n                zIndex: zIndex - _this.addedSlide,\n                slideIndex: newAddedSlideIndex,\n                dataIndex: insertDataIndex,\n                key: _this.keyCount\n              };\n              newSlides.splice(steps > 0 ? insertPosition + 1 : insertPosition, 0, insertSlide);\n            }\n\n            newAddedSlideIndex += updateCount;\n          }\n        })();\n      }\n\n      if (steps !== 0 && onActiveSlideChange) {\n        onActiveSlideChange(newCenterDataIndex);\n      }\n\n      _this.setState(function () {\n        return {\n          swipeStarted: false,\n          renderedSlides: newSlides,\n          swipRight: disableSwipeRightState ? false : steps < 0 ? true : false\n        };\n      }, function () {\n        setTimeout(function () {\n          _this.resetSlides();\n        }, 0);\n      });\n    };\n\n    _this.getSlideDOMInfo = function (slideIndex) {\n      var slideWidth = _this.props.slideWidth;\n      var listRef = _this.listRef.current;\n      var slideDOM = listRef.getElementsByClassName(\"react-stacked-center-carousel-slide-\" + slideIndex)[0];\n      var slideRect = slideDOM.getBoundingClientRect();\n\n      var _listRef$getBoundingC = listRef.getBoundingClientRect(),\n          carouselLeft = _listRef$getBoundingC.left;\n\n      var scale = slideRect.width / slideWidth;\n      var additionalOffset = slideWidth * 0.5 * (1 - scale);\n      var slideOffsetLeft = slideRect.left - carouselLeft - additionalOffset;\n      var slideCenterOffset = slideOffsetLeft - _this.centerPosition;\n      return {\n        scale: scale,\n        slideDOM: slideDOM,\n        slideCenterOffset: slideCenterOffset\n      };\n    };\n\n    _this.getSlideScaleAndOpacity = function (centerOffset) {\n      var targetSlide = _this.sortedSlideInfo.find(function (_ref6) {\n        var position = _ref6.position;\n        return Math.ceil(position) >= centerOffset;\n      }) || _this.sortedSlideInfo[_this.sortedSlideInfo.length - 1];\n\n      var position = targetSlide.position,\n          slideIndex = targetSlide.slideIndex,\n          scale = targetSlide.scale,\n          maxTransformDistance = targetSlide.maxTransformDistance,\n          maxTransformScale = targetSlide.maxTransformScale,\n          maxTransformOpacity = targetSlide.maxTransformOpacity,\n          opacity = targetSlide.opacity;\n      var offset = Math.ceil(position) - centerOffset;\n      var offsetPercentage = maxTransformDistance.left === 0 ? 0 : offset / maxTransformDistance.left * (slideIndex <= 0 ? -1 : 1);\n      return {\n        scale: scale + maxTransformScale.left * offsetPercentage,\n        opacity: opacity + maxTransformOpacity.left * offsetPercentage\n      };\n    };\n\n    _this.centerOffset = function (slideIndex) {\n      var _this$getSlideDOMInfo2 = _this.getSlideDOMInfo(slideIndex),\n          slideCenterOffset = _this$getSlideDOMInfo2.slideCenterOffset;\n\n      return Math.abs(_this.slideInfoMap[0].position - slideCenterOffset);\n    };\n\n    _this.onSwipeStart = function (e) {\n      var _this$props4 = _this.props,\n          onActiveSlideChange = _this$props4.onActiveSlideChange,\n          disableSwipe = _this$props4.disableSwipe;\n      if (disableSwipe) return;\n\n      var initalSwipeX = _this.getSwipeX(e);\n\n      var renderedSlides = _this.state.renderedSlides;\n      clearTimeout(_this.clearSlideTimeout);\n      var shiftDirection = 0;\n      var centerDataIndex = 0;\n      if (_this.centerOffset(-1) < _this.centerOffset(0)) shiftDirection = 1;else if (_this.centerOffset(1) < _this.centerOffset(0)) shiftDirection = -1;\n      var newRenderedSlides = [];\n      var swipePositionInfo = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(renderedSlides), _step; !(_step = _iterator()).done;) {\n        var slide = _step.value;\n        var slideIndex = slide.slideIndex,\n            dataIndex = slide.dataIndex;\n\n        if (dataIndex === -1) {\n          newRenderedSlides.push(slide);\n          swipePositionInfo.push({\n            slideIndex: slideIndex,\n            maxLeft: 0,\n            maxRight: 0\n          });\n          continue;\n        }\n\n        var newSlideIndex = slideIndex + shiftDirection;\n        if (Math.abs(newSlideIndex) > _this.slidePerSide) continue;\n        if (newSlideIndex === 0) centerDataIndex = dataIndex;\n\n        var _this$getSlideDOMInfo3 = _this.getSlideDOMInfo(slideIndex),\n            slideCenterOffset = _this$getSlideDOMInfo3.slideCenterOffset,\n            scale = _this$getSlideDOMInfo3.scale;\n\n        var _this$getSlideScaleAn = _this.getSlideScaleAndOpacity(slideCenterOffset),\n            opacity = _this$getSlideScaleAn.opacity;\n\n        var _this$safeGetSlideInf = _this.safeGetSlideInfo(newSlideIndex),\n            maxTransformDistance = _this$safeGetSlideInf.maxTransformDistance,\n            position = _this$safeGetSlideInf.position;\n\n        swipePositionInfo.push({\n          slideIndex: newSlideIndex,\n          maxLeft: slideCenterOffset - position + maxTransformDistance.left,\n          maxRight: position + maxTransformDistance.right - slideCenterOffset\n        });\n        newRenderedSlides.push(_extends({}, slide, {\n          scale: scale,\n          opacity: opacity,\n          position: slideCenterOffset,\n          slideIndex: newSlideIndex,\n          zIndex: _this.getZIndex(newSlideIndex)\n        }));\n      }\n\n      if (onActiveSlideChange && shiftDirection !== 0) {\n        onActiveSlideChange(centerDataIndex);\n      }\n\n      _this.setState({\n        swipeStarted: true,\n        initalSwipeX: initalSwipeX,\n        renderedSlides: newRenderedSlides,\n        prevRenderedSlides: [].concat(newRenderedSlides),\n        swipePositionInfo: swipePositionInfo\n      });\n    };\n\n    _this.onSwipe = function (e) {\n      var swipeStarted = _this.state.swipeStarted;\n\n      if (!swipeStarted) {\n        return;\n      }\n\n      var _this$state = _this.state,\n          initalSwipeX = _this$state.initalSwipeX,\n          prevRenderedSlides = _this$state.prevRenderedSlides,\n          swipePositionInfo = _this$state.swipePositionInfo;\n      var slideWidth = _this.props.slideWidth;\n      var tempShift = false;\n\n      var currentSwipeX = _this.getSwipeX(e);\n\n      var swipeDistance = initalSwipeX - currentSwipeX;\n      var delta = Math.abs(swipeDistance);\n      var swipeLeft = swipeDistance > 0;\n      var transformFactor = 10 / slideWidth * delta;\n      var transformPercentage = 1 - Math.pow(1 - (_this.props.swipeSpeed || 0.5), transformFactor);\n      var newRenderedSlides = prevRenderedSlides.map(function (slide, index) {\n        var position = slide.position,\n            slideIndex = slide.slideIndex,\n            dataIndex = slide.dataIndex;\n        if (dataIndex === -1) return slide;\n        var maxDeltaX = swipePositionInfo[index][swipeLeft ? 'maxLeft' : 'maxRight'];\n        var targetPosition = position + (swipeLeft ? -1 : 1) * maxDeltaX * transformPercentage;\n\n        var _this$getSlideScaleAn2 = _this.getSlideScaleAndOpacity(targetPosition),\n            scale = _this$getSlideScaleAn2.scale,\n            opacity = _this$getSlideScaleAn2.opacity;\n\n        var zIndex = slide.zIndex;\n\n        if (Math.abs(slideIndex) === 1) {\n          if (_this.centerOffset(slideIndex) < _this.centerOffset(0)) {\n            zIndex = _this.maxZIndex;\n            tempShift = true;\n          }\n        }\n\n        return _extends({}, slide, {\n          position: targetPosition,\n          scale: scale,\n          opacity: opacity,\n          zIndex: zIndex\n        });\n      });\n\n      _this.setState({\n        renderedSlides: newRenderedSlides,\n        tempShift: tempShift\n      });\n    };\n\n    _this.resetSlides = function () {\n      var renderedSlides = _this.state.renderedSlides;\n      var newDefault = renderedSlides.map(function (slide) {\n        var _this$safeGetSlideInf2 = _this.safeGetSlideInfo(slide.slideIndex),\n            opacity = _this$safeGetSlideInf2.opacity,\n            scale = _this$safeGetSlideInf2.scale,\n            position = _this$safeGetSlideInf2.position;\n\n        return _extends({}, slide, {\n          zIndex: _this.getZIndex(slide.slideIndex),\n          opacity: opacity,\n          scale: scale,\n          position: position\n        });\n      });\n\n      _this.setState(function () {\n        return {\n          renderedSlides: newDefault,\n          swipRight: false\n        };\n      }, _this.debouncedClearInvisibleSlide);\n    };\n\n    _this.onSwipeEnd = function () {\n      var swipeStarted = _this.state.swipeStarted;\n      if (!swipeStarted) return;\n      var renderedSlides = _this.state.renderedSlides;\n      var newCenterSlide = renderedSlides.find(function (_ref7) {\n        var zIndex = _ref7.zIndex;\n        return zIndex === _this.maxZIndex;\n      });\n\n      _this.moveCarousel((newCenterSlide === null || newCenterSlide === void 0 ? void 0 : newCenterSlide.slideIndex) || 0);\n\n      _this.setState({\n        tempShift: false\n      });\n    };\n\n    _this.goNext = function () {\n      _this.moveCarousel(1);\n    };\n\n    _this.goBack = function () {\n      _this.moveCarousel(-1);\n    };\n\n    _this.swipeTo = function (steps) {\n      _this.moveCarousel(steps);\n    };\n\n    var _this$initializePrope = _this.initializeProperties(true),\n        renderedSlides = _this$initializePrope.renderedSlides,\n        slideInfoMap = _this$initializePrope.slideInfoMap,\n        slidePerSide = _this$initializePrope.slidePerSide,\n        sortedSlideInfo = _this$initializePrope.sortedSlideInfo,\n        centerPosition = _this$initializePrope.centerPosition,\n        renderedSlidePerSide = _this$initializePrope.renderedSlidePerSide;\n\n    var onActiveSlideChange = _this.props.onActiveSlideChange;\n    _this.slideInfoMap = slideInfoMap;\n    _this.sortedSlideInfo = sortedSlideInfo;\n    _this.slidePerSide = slidePerSide;\n    _this.height = _this.props.height || 0;\n    _this.listRef = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.clearSlideTimeout = null;\n    _this.keyCount = props.data.length;\n    _this.addedSlide = 0;\n    _this.centerPosition = centerPosition;\n    _this.maxZIndex = 100;\n    _this.renderedSlidePerSide = renderedSlidePerSide;\n\n    if (onActiveSlideChange) {\n      onActiveSlideChange(0);\n    }\n\n    _this.state = {\n      initalSwipeX: 0,\n      swipeStarted: false,\n      renderedSlides: renderedSlides,\n      prevRenderedSlides: [].concat(renderedSlides),\n      swipePositionInfo: [],\n      swipRight: false,\n      tempShift: false\n    };\n    return _this;\n  }\n\n  var _proto = StackedCarousel.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateHeight();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    clearTimeout(this.clearSlideTimeout);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (!shouldRecaclculate(this.props, prevProps)) return;\n\n    var _this$initializePrope2 = this.initializeProperties(this.props.maxVisibleSlide !== prevProps.maxVisibleSlide),\n        slideInfoMap = _this$initializePrope2.slideInfoMap,\n        slidePerSide = _this$initializePrope2.slidePerSide,\n        newRenderedSlides = _this$initializePrope2.newRenderedSlides,\n        sortedSlideInfo = _this$initializePrope2.sortedSlideInfo,\n        centerPosition = _this$initializePrope2.centerPosition;\n\n    this.slideInfoMap = slideInfoMap;\n    this.sortedSlideInfo = sortedSlideInfo;\n    this.slidePerSide = slidePerSide;\n    this.centerPosition = centerPosition;\n    this.setState(function () {\n      return {\n        initalSwipeX: 0,\n        renderedSlides: newRenderedSlides,\n        prevRenderedSlides: [].concat(newRenderedSlides),\n        swipRight: false\n      };\n    }, this.updateHeight);\n  };\n\n  _proto.getSwipeX = function getSwipeX(e) {\n    if (e.type[0] === 'm') return e.clientX;\n\n    try {\n      var _e$touches$, _e$changedTouches$;\n\n      return ((_e$touches$ = e.touches[0]) === null || _e$touches$ === void 0 ? void 0 : _e$touches$.clientX) || ((_e$changedTouches$ = e.changedTouches[0]) === null || _e$changedTouches$ === void 0 ? void 0 : _e$changedTouches$.clientX);\n    } catch (_unused) {\n      throw Error('Something went wrong with getting mouse position');\n    }\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$state2 = this.state,\n        swipeStarted = _this$state2.swipeStarted,\n        renderedSlides = _this$state2.renderedSlides,\n        swipRight = _this$state2.swipRight,\n        tempShift = _this$state2.tempShift;\n    var _this$props5 = this.props,\n        Component = _this$props5.slideComponent,\n        _this$props5$transiti = _this$props5.transitionTime,\n        transitionTime = _this$props5$transiti === void 0 ? StackedCarousel.defaultTransitionTime : _this$props5$transiti,\n        className = _this$props5.className,\n        data = _this$props5.data,\n        slideWidth = _this$props5.slideWidth,\n        customTransition = _this$props5.customTransition,\n        carouselWidth = _this$props5.carouselWidth,\n        useGrabCursor = _this$props5.useGrabCursor,\n        height = _this$props5.height;\n    var cursor = useGrabCursor && (swipeStarted ? 'grabbing' : 'grab') || 'default';\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      className: \"react-stacked-center-carousel \" + (className || ''),\n      onMouseDown: this.onSwipeStart,\n      onMouseUp: this.onSwipeEnd,\n      onMouseMove: this.onSwipe,\n      onMouseLeave: this.onSwipeEnd,\n      onTouchStart: this.onSwipeStart,\n      onTouchMove: this.onSwipe,\n      onTouchEnd: this.onSwipeEnd,\n      ref: this.listRef,\n      style: {\n        width: carouselWidth,\n        height: height || this.height,\n        position: 'relative',\n        overflow: 'hidden',\n        cursor: cursor\n      }\n    }, renderedSlides.map(function (_ref8) {\n      var opacity = _ref8.opacity,\n          slideIndex = _ref8.slideIndex,\n          dataIndex = _ref8.dataIndex,\n          position = _ref8.position,\n          scale = _ref8.scale,\n          key = _ref8.key,\n          zIndex = _ref8.zIndex;\n      var ID = dataIndex === -1 ? \"hidden-\" + key : slideIndex;\n      var zDuration = transitionTime * (swipRight ? 0.6 : 1);\n      var transition = swipeStarted ? 'none' : customTransition || \"all \" + transitionTime + \"ms ease, z-index \" + zDuration + \"ms ease\";\n      var isCenterSlide = tempShift ? zIndex === _this2.maxZIndex : slideIndex === 0;\n      return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        key: key,\n        className: \"react-stacked-center-carousel-slide-\" + ID,\n        draggable: false,\n        style: {\n          position: 'absolute',\n          display: 'flex',\n          left: \"calc(50% - \" + slideWidth / 2 + \"px)\",\n          transform: \"translateX(\" + position + \"px) scale(\" + scale + \")\",\n          width: slideWidth,\n          transition: transition,\n          opacity: opacity,\n          zIndex: zIndex\n        }\n      }, dataIndex !== -1 && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, {\n        dataIndex: dataIndex,\n        data: data,\n        slideIndex: slideIndex,\n        isCenterSlide: isCenterSlide,\n        swipeTo: _this2.swipeTo\n      }));\n    }));\n  };\n\n  return StackedCarousel;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nStackedCarousel.defaultScaleFactor = 0.85;\nStackedCarousel.defaultTransitionTime = 450;\n\nfunction shouldRecaclculate(prop1, prop2) {\n  var _prop1$customScales, _prop2$customScales;\n\n  if (prop1.slideWidth !== prop2.slideWidth || prop1.carouselWidth !== prop2.carouselWidth || prop1.maxVisibleSlide !== prop2.maxVisibleSlide || prop1.currentVisibleSlide !== prop2.currentVisibleSlide || prop1.fadeDistance !== prop2.fadeDistance || ((_prop1$customScales = prop1.customScales) === null || _prop1$customScales === void 0 ? void 0 : _prop1$customScales.join('')) !== ((_prop2$customScales = prop2.customScales) === null || _prop2$customScales === void 0 ? void 0 : _prop2$customScales.join(''))) return true;\n  return false;\n}\n\nfunction ResponsiveContainer(props) {\n  var render = props.render,\n      carouselRef = props.carouselRef;\n\n  var _useResizeDetector = (0,react_resize_detector__WEBPACK_IMPORTED_MODULE_1__.useResizeDetector)(),\n      width = _useResizeDetector.width,\n      ref = _useResizeDetector.ref;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: ref,\n    className: 'stacked-carousel-responsive-container',\n    style: {\n      width: '100%'\n    }\n  }, width && render(width, carouselRef));\n}\n\n\n//# sourceMappingURL=index.modern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3RhY2tlZC1jZW50ZXItY2Fyb3VzZWwvZGlzdC9pbmRleC5tb2Rlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDZ0M7O0FBRTFEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBOztBQUVBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQywrQkFBK0I7QUFDOUUsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBOztBQUVBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMERBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQkFBc0IsMERBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLDREQUFtQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsd0VBQWlCO0FBQzVDO0FBQ0E7O0FBRUEsU0FBUywwREFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFZ0Q7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9nLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdGFja2VkLWNlbnRlci1jYXJvdXNlbC9kaXN0L2luZGV4Lm1vZGVybi5qcz8wNDI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gJ3JlYWN0LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcblxuICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgU3RhY2tlZENhcm91c2VsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShTdGFja2VkQ2Fyb3VzZWwsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGFja2VkQ2Fyb3VzZWwocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRQdXJlQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy52YWxpZGF0ZVByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgc3dpcGVTcGVlZCA9IF90aGlzJHByb3BzLnN3aXBlU3BlZWQsXG4gICAgICAgICAgY3VycmVudFZpc2libGVTbGlkZSA9IF90aGlzJHByb3BzLmN1cnJlbnRWaXNpYmxlU2xpZGUsXG4gICAgICAgICAgbWF4VmlzaWJsZVNsaWRlID0gX3RoaXMkcHJvcHMubWF4VmlzaWJsZVNsaWRlLFxuICAgICAgICAgIGZhZGVEaXN0YW5jZSA9IF90aGlzJHByb3BzLmZhZGVEaXN0YW5jZSxcbiAgICAgICAgICBjdXN0b21TY2FsZXMgPSBfdGhpcyRwcm9wcy5jdXN0b21TY2FsZXMsXG4gICAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IChtYXhWaXNpYmxlU2xpZGUgKyAxKSAvIDIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3lvdSBtdXN0IGhhdmUgbW9yZSB0aGFuIChtYXhWaXNpYmxlU2xpZGUgKyAxKSAvIDIgZGF0YSBpdGVtJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50VmlzaWJsZVNsaWRlICYmIGN1cnJlbnRWaXNpYmxlU2xpZGUgJSAyICE9PSAxIHx8IG1heFZpc2libGVTbGlkZSAlIDIgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2N1cnJlbnRWaXNpYmxlU2xpZGUgb3IgbWF4VmlzaWJsZVNsaWRlIG11c3QgYmUgYW4gb2RkIG51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFZpc2libGVTbGlkZSAmJiBjdXJyZW50VmlzaWJsZVNsaWRlID4gbWF4VmlzaWJsZVNsaWRlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjdXJyZW50VmlzaWJsZVNsaWRlIG11c3QgYmUgc21hbGxlciB0aGFuIG1heFZpc2libGVTbGlkZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmFkZURpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGZhZGVEaXN0YW5jZSA+IDEgfHwgZmFkZURpc3RhbmNlIDwgMCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdmYWRlRGlzdGFuY2UgaXMgYSBwZXJjZW50YWdlIHZhbHVlIGluIHRoZSByYW5nZSBvZiAwIC0gMScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21TY2FsZXMgJiYgY3VzdG9tU2NhbGVzLmxlbmd0aCAhPT0gKG1heFZpc2libGVTbGlkZSArIDMpIC8gMikge1xuICAgICAgICB0aHJvdyBFcnJvcignY3VzdG9tU2NhbGVzIG11c3QgaGF2ZSBsZW5naCAobWF4VmlzaWJsZVNsaWRlICsgMykgLyAyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZVNwZWVkICYmIChzd2lwZVNwZWVkID4gMC45OSB8fCBzd2lwZVNwZWVkIDwgMC4wMSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3N3aXBlU3BlZWQgbXVzdCBoYXZlIGEgdmFsdWUgYmV0d2VlbiAwLjAxIGFuZCAwLjk5Jyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmluaXRpYWxpemVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoY29uc3RydWN0b3IgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdHJ1Y3RvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy52YWxpZGF0ZVByb3BzKCk7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjYXJvdXNlbFdpZHRoID0gX3RoaXMkcHJvcHMyLmNhcm91c2VsV2lkdGgsXG4gICAgICAgICAgc2xpZGVXaWR0aCA9IF90aGlzJHByb3BzMi5zbGlkZVdpZHRoLFxuICAgICAgICAgIGN1cnJlbnRWaXNpYmxlRGlzcGxheVNsaWRlID0gX3RoaXMkcHJvcHMyLmN1cnJlbnRWaXNpYmxlU2xpZGUsXG4gICAgICAgICAgbWF4VmlzaWJsZVNsaWRlID0gX3RoaXMkcHJvcHMyLm1heFZpc2libGVTbGlkZTtcbiAgICAgIHZhciBjdXJyZW50VmlzaWJsZVNsaWRlcyA9IGN1cnJlbnRWaXNpYmxlRGlzcGxheVNsaWRlIHx8IG1heFZpc2libGVTbGlkZTtcbiAgICAgIHZhciB2aXNpYmxlU2xpZGVQZXJTaWRlID0gKGN1cnJlbnRWaXNpYmxlU2xpZGVzIC0gMSkgLyAyO1xuICAgICAgdmFyIHNsaWRlUGVyU2lkZSA9IE1hdGgubWF4KHZpc2libGVTbGlkZVBlclNpZGUgKyAxLCAxKTtcbiAgICAgIHZhciB0b3RhbFJlbmRlckNvdW50ID0gbWF4VmlzaWJsZVNsaWRlICsgMjtcbiAgICAgIHZhciByZW5kZXJlZFNsaWRlUGVyU2lkZSA9IChtYXhWaXNpYmxlU2xpZGUgKyAxKSAvIDI7XG5cbiAgICAgIHZhciBfdGhpcyRjYWxjdWxhdGVTY2FsZUEgPSBfdGhpcy5jYWxjdWxhdGVTY2FsZUFuZE9mZnNldHMoc2xpZGVQZXJTaWRlKSxcbiAgICAgICAgICBvZmZzZXRzID0gX3RoaXMkY2FsY3VsYXRlU2NhbGVBLm9mZnNldHMsXG4gICAgICAgICAgc2NhbGVkT2Zmc2V0cyA9IF90aGlzJGNhbGN1bGF0ZVNjYWxlQS5zY2FsZWRPZmZzZXRzLFxuICAgICAgICAgIHNjYWxlcyA9IF90aGlzJGNhbGN1bGF0ZVNjYWxlQS5zY2FsZXM7XG5cbiAgICAgIHZhciBuZXdSZW5kZXJlZFNsaWRlcyA9IGNvbnN0cnVjdG9yID8gQXJyYXkodG90YWxSZW5kZXJDb3VudCkuZmlsbChudWxsKSA6IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IF9yZWYuc2xpZGVJbmRleCxcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IF9yZWYuZGF0YUluZGV4O1xuICAgICAgICByZXR1cm4gZGF0YUluZGV4ID09PSAtMSB8fCBNYXRoLmFicyhzbGlkZUluZGV4KSA8PSBfdGhpcy5zbGlkZVBlclNpZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciBzbGlkZUluZm9NYXAgPSB7fTtcbiAgICAgIHZhciBuZXdDZW50ZXJTbGlkZVJlbGF0aXZlSW5kZXggPSBjb25zdHJ1Y3RvciA/ICh0b3RhbFJlbmRlckNvdW50IC0gMSkgLyAyIDogbmV3UmVuZGVyZWRTbGlkZXMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IF9yZWYyLnNsaWRlSW5kZXg7XG4gICAgICAgIHJldHVybiBzbGlkZUluZGV4ID09PSAwO1xuICAgICAgfSk7XG4gICAgICB2YXIgbmV3Q2VudGVyRGF0YUluZGV4ID0gY29uc3RydWN0b3IgPyAwIDogbmV3UmVuZGVyZWRTbGlkZXNbbmV3Q2VudGVyU2xpZGVSZWxhdGl2ZUluZGV4XS5kYXRhSW5kZXg7XG4gICAgICB2YXIgZmlsbGVkV2lkdGggPSAwO1xuICAgICAgdmFyIGNlbnRlclBvc2l0aW9uID0gY2Fyb3VzZWxXaWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMjtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoYWJzSW5kZXgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYWJzSW5kZXhdO1xuICAgICAgICB2YXIgc2xpZGVTY2FsZSA9IHNjYWxlc1thYnNJbmRleF07XG4gICAgICAgIHZhciBjdXJyZW50T2ZmU2V0ID0gZmlsbGVkV2lkdGggKyBvZmZzZXQ7XG4gICAgICAgIFstYWJzSW5kZXgsIGFic0luZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlSW5kZXggPSBuZXdDZW50ZXJTbGlkZVJlbGF0aXZlSW5kZXggKyBzbGlkZUluZGV4O1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHNsaWRlSW5kZXggPj0gMCA/IGN1cnJlbnRPZmZTZXQgOiAtY3VycmVudE9mZlNldDtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IGFic0luZGV4ID09PSBzbGlkZVBlclNpZGUgPyAwIDogMTtcblxuICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBfdGhpcy5tb2REYXRhUmFuZ2UobmV3Q2VudGVyRGF0YUluZGV4ICsgc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICBuZXdSZW5kZXJlZFNsaWRlc1tyZWxhdGl2ZUluZGV4XSA9IHtcbiAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgICAgICAgc2NhbGU6IHNsaWRlU2NhbGUsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBzbGlkZUluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgIHpJbmRleDogcmVuZGVyZWRTbGlkZVBlclNpZGUgLSBNYXRoLmFicyhzbGlkZUluZGV4KSxcbiAgICAgICAgICAgIGtleTogY29uc3RydWN0b3IgPyBzbGlkZUluZGV4IDogbmV3UmVuZGVyZWRTbGlkZXNbcmVsYXRpdmVJbmRleF0ua2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbc2xpZGVJbmRleF0gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBzY2FsZTogc2xpZGVTY2FsZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFic0luZGV4ICE9PSAwKSBmaWxsZWRXaWR0aCArPSBzY2FsZWRPZmZzZXRzW2Fic0luZGV4XTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGFic0luZGV4ID0gMDsgYWJzSW5kZXggPD0gc2xpZGVQZXJTaWRlOyBhYnNJbmRleCsrKSB7XG4gICAgICAgIF9sb29wKGFic0luZGV4KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IC1zbGlkZVBlclNpZGU7IGkgPD0gc2xpZGVQZXJTaWRlOyBpKyspIHtcbiAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybURpc3RhbmNlID0ge307XG4gICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1TY2FsZSA9IHt9O1xuICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtT3BhY2l0eSA9IHtcbiAgICAgICAgICBsZWZ0OiBpID09PSAtc2xpZGVQZXJTaWRlICsgMSB8fCBpID09PSBzbGlkZVBlclNpZGUgPyAxIDogMCxcbiAgICAgICAgICByaWdodDogaSA9PT0gLXNsaWRlUGVyU2lkZSB8fCBpID09PSBzbGlkZVBlclNpZGUgLSAxID8gMSA6IDBcbiAgICAgICAgfTtcbiAgICAgICAgc2xpZGVJbmZvTWFwW2ldLnNsaWRlSW5kZXggPSBpO1xuXG4gICAgICAgIGlmIChpID09PSAtc2xpZGVQZXJTaWRlKSB7XG4gICAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybURpc3RhbmNlLmxlZnQgPSAwO1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1TY2FsZS5sZWZ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtRGlzdGFuY2UubGVmdCA9IHNsaWRlSW5mb01hcFtpXS5wb3NpdGlvbiAtIHNsaWRlSW5mb01hcFtpIC0gMV0ucG9zaXRpb247XG4gICAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybVNjYWxlLmxlZnQgPSBNYXRoLmFicyhzbGlkZUluZm9NYXBbaV0uc2NhbGUgLSBzbGlkZUluZm9NYXBbaSAtIDFdLnNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09PSBzbGlkZVBlclNpZGUpIHtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtRGlzdGFuY2UucmlnaHQgPSAwO1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1TY2FsZS5yaWdodCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybURpc3RhbmNlLnJpZ2h0ID0gc2xpZGVJbmZvTWFwW2kgKyAxXS5wb3NpdGlvbiAtIHNsaWRlSW5mb01hcFtpXS5wb3NpdGlvbjtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtU2NhbGUucmlnaHQgPSBNYXRoLmFicyhzbGlkZUluZm9NYXBbaSArIDFdLnNjYWxlIC0gc2xpZGVJbmZvTWFwW2ldLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF4VmlzaWJsZVNsaWRlID4gY3VycmVudFZpc2libGVTbGlkZXMpIHtcbiAgICAgICAgdmFyIG1heFJlbmRlcmVkU2xpZGVQZXJTaWRlID0gKG1heFZpc2libGVTbGlkZSArIDEpIC8gMjtcbiAgICAgICAgdmFyIGN1cnJlbnRTbGlkZVBlclNpZGUgPSBzbGlkZVBlclNpZGU7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSBjdXJyZW50U2xpZGVQZXJTaWRlICsgMTsgX2kgPD0gbWF4UmVuZGVyZWRTbGlkZVBlclNpZGU7IF9pKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBkaXJlY3QgPSAxOyBkaXJlY3QgPj0gMDsgZGlyZWN0LS0pIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnRJbmRleCA9IG5ld0NlbnRlclNsaWRlUmVsYXRpdmVJbmRleCArIChkaXJlY3QgPT09IDEgPyBfaSA6IC1faSk7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gaW5zZXJ0SW5kZXggKyAoZGlyZWN0ID09PSAxID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBzbGlkZUluZGV4ID0gZGlyZWN0ID09PSAxID8gX2kgOiAtX2k7XG4gICAgICAgICAgICB2YXIgc2NhbGVQb3NpdGlvbkluZGV4ID0gY29uc3RydWN0b3IgPyBwcmV2SW5kZXggOiBpbnNlcnRJbmRleDtcbiAgICAgICAgICAgIG5ld1JlbmRlcmVkU2xpZGVzW2luc2VydEluZGV4XSA9IHtcbiAgICAgICAgICAgICAgc2NhbGU6IG5ld1JlbmRlcmVkU2xpZGVzW3NjYWxlUG9zaXRpb25JbmRleF0uc2NhbGUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdSZW5kZXJlZFNsaWRlc1tzY2FsZVBvc2l0aW9uSW5kZXhdLnBvc2l0aW9uLFxuICAgICAgICAgICAgICBrZXk6IGNvbnN0cnVjdG9yID8gLXNsaWRlSW5kZXggOiBuZXdSZW5kZXJlZFNsaWRlc1tpbnNlcnRJbmRleF0ua2V5LFxuICAgICAgICAgICAgICBkYXRhSW5kZXg6IC0xLFxuICAgICAgICAgICAgICBzbGlkZUluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICB6SW5kZXg6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3J0ZWRTbGlkZUluZm8gPSBPYmplY3QudmFsdWVzKHNsaWRlSW5mb01hcCk7XG4gICAgICBzb3J0ZWRTbGlkZUluZm8uc29ydChmdW5jdGlvbiAoc2xpZGUxLCBzbGlkZTIpIHtcbiAgICAgICAgcmV0dXJuIHNsaWRlMS5wb3NpdGlvbiAtIHNsaWRlMi5wb3NpdGlvbjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld1JlbmRlcmVkU2xpZGVzLFxuICAgICAgICBjZW50ZXJTbGlkZVJlbGF0aXZlSW5kZXg6IG5ld0NlbnRlclNsaWRlUmVsYXRpdmVJbmRleCxcbiAgICAgICAgc2xpZGVJbmZvTWFwOiBzbGlkZUluZm9NYXAsXG4gICAgICAgIHNsaWRlUGVyU2lkZTogc2xpZGVQZXJTaWRlLFxuICAgICAgICBuZXdSZW5kZXJlZFNsaWRlczogbmV3UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHNvcnRlZFNsaWRlSW5mbzogc29ydGVkU2xpZGVJbmZvLFxuICAgICAgICBjZW50ZXJQb3NpdGlvbjogY2VudGVyUG9zaXRpb24sXG4gICAgICAgIHJlbmRlcmVkU2xpZGVQZXJTaWRlOiByZW5kZXJlZFNsaWRlUGVyU2lkZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2FsY3VsYXRlU2NhbGVBbmRPZmZzZXRzID0gZnVuY3Rpb24gKHNsaWRlUGVyU2lkZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNhcm91c2VsV2lkdGggPSBfdGhpcyRwcm9wczMuY2Fyb3VzZWxXaWR0aCxcbiAgICAgICAgICBzbGlkZVdpZHRoID0gX3RoaXMkcHJvcHMzLnNsaWRlV2lkdGgsXG4gICAgICAgICAgY3VzdG9tU2NhbGVzID0gX3RoaXMkcHJvcHMzLmN1c3RvbVNjYWxlcyxcbiAgICAgICAgICBmYWRlRGlzdGFuY2UgPSBfdGhpcyRwcm9wczMuZmFkZURpc3RhbmNlO1xuICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlID0gY2Fyb3VzZWxXaWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMjtcbiAgICAgIHZhciBzY2FsZXMgPSBbMV07XG4gICAgICB2YXIgc2NhbGVkU2xpZGVXaWR0aHMgPSBbc2xpZGVXaWR0aF07XG5cbiAgICAgIGZvciAodmFyIHNsaWRlID0gMTsgc2xpZGUgPD0gc2xpZGVQZXJTaWRlOyBzbGlkZSsrKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGN1c3RvbVNjYWxlcyA/IGN1c3RvbVNjYWxlc1tzbGlkZV0gOiBNYXRoLnBvdyhTdGFja2VkQ2Fyb3VzZWwuZGVmYXVsdFNjYWxlRmFjdG9yLCBzbGlkZSk7XG4gICAgICAgIHNjYWxlcy5wdXNoKHNjYWxlKTtcbiAgICAgICAgc2NhbGVkU2xpZGVXaWR0aHMucHVzaChzbGlkZVdpZHRoICogc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5jbHVkZWRTbGlkZVdpZHRocyA9IHNjYWxlZFNsaWRlV2lkdGhzLnNsaWNlKDEpO1xuICAgICAgdmFyIGZpbGxpbmdTcGFjZSA9IGF2YWlsYWJsZVNwYWNlO1xuXG4gICAgICBpZiAoZmFkZURpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5jbHVkZWRTbGlkZVdpZHRocyA9IHNjYWxlZFNsaWRlV2lkdGhzLnNsaWNlKDEsIHNsaWRlUGVyU2lkZSk7XG4gICAgICAgIGZpbGxpbmdTcGFjZSA9IGF2YWlsYWJsZVNwYWNlICogKDEgLSBmYWRlRGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxTbGlkZVdpZHRoID0gaW5jbHVkZWRTbGlkZVdpZHRocy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgb2ZmU2V0UGVyY2VudGFnZSA9IHRvdGFsU2xpZGVXaWR0aCA/IGZpbGxpbmdTcGFjZSAvIHRvdGFsU2xpZGVXaWR0aCA6IDA7XG4gICAgICB2YXIgc2NhbGVkT2Zmc2V0cyA9IFswXTtcbiAgICAgIHZhciBvZmZzZXRzID0gWzBdO1xuXG4gICAgICBmb3IgKHZhciBfc2xpZGUgPSAxOyBfc2xpZGUgPD0gc2xpZGVQZXJTaWRlOyBfc2xpZGUrKykge1xuICAgICAgICB2YXIgaXNDdXN0b21GYWRlID0gZmFkZURpc3RhbmNlICE9PSB1bmRlZmluZWQgJiYgX3NsaWRlID09PSBzbGlkZVBlclNpZGU7XG4gICAgICAgIHZhciBfc2NhbGUgPSBzY2FsZXNbX3NsaWRlXTtcbiAgICAgICAgc2NhbGVkT2Zmc2V0c1tfc2xpZGVdID0gaXNDdXN0b21GYWRlID8gZmFkZURpc3RhbmNlICogYXZhaWxhYmxlU3BhY2UgOiBzbGlkZVdpZHRoICogX3NjYWxlICogb2ZmU2V0UGVyY2VudGFnZTtcbiAgICAgICAgb2Zmc2V0c1tfc2xpZGVdID0gc2NhbGVkT2Zmc2V0c1tfc2xpZGVdICsgc2xpZGVXaWR0aCAqICgoMSAtIF9zY2FsZSkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgc2NhbGVkT2Zmc2V0czogc2NhbGVkT2Zmc2V0cyxcbiAgICAgICAgc2NhbGVzOiBzY2FsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmdldFpJbmRleCA9IGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVuZGVyZWRTbGlkZVBlclNpZGUgLSBNYXRoLmFicyhzbGlkZUluZGV4KTtcbiAgICB9O1xuXG4gICAgX3RoaXMudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhlaWdodCA9IF90aGlzLnByb3BzLmhlaWdodDtcbiAgICAgIGlmIChoZWlnaHQpIHJldHVybjtcblxuICAgICAgdmFyIF90aGlzJGdldFNsaWRlRE9NSW5mbyA9IF90aGlzLmdldFNsaWRlRE9NSW5mbygwKSxcbiAgICAgICAgICBzbGlkZURPTSA9IF90aGlzJGdldFNsaWRlRE9NSW5mby5zbGlkZURPTTtcblxuICAgICAgdmFyIHBhcnNlZEhlaWdodCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlRE9NKS5oZWlnaHQpO1xuXG4gICAgICBpZiAocGFyc2VkSGVpZ2h0ICE9PSBfdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gcGFyc2VkSGVpZ2h0O1xuXG4gICAgICAgIF90aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm1vZERhdGFSYW5nZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnByb3BzLmRhdGE7XG4gICAgICB2YXIgbSA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmV0dXJuIChuICUgbSArIG0pICUgbTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZGVib3VuY2VkQ2xlYXJJbnZpc2libGVTbGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uVGltZSA9IF90aGlzLnByb3BzLnRyYW5zaXRpb25UaW1lO1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNsZWFyU2xpZGVUaW1lb3V0KTtcbiAgICAgIF90aGlzLmNsZWFyU2xpZGVUaW1lb3V0ID0gc2V0VGltZW91dChfdGhpcy5jbGVhclVzZWxlc3NTbGlkZSwgdHJhbnNpdGlvblRpbWUgIT09IHVuZGVmaW5lZCA/IHRyYW5zaXRpb25UaW1lIDogU3RhY2tlZENhcm91c2VsLmRlZmF1bHRUcmFuc2l0aW9uVGltZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsZWFyVXNlbGVzc1NsaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWRkZWRTbGlkZSA9IDA7XG4gICAgICB2YXIgcmVuZGVyZWRTbGlkZXMgPSBfdGhpcy5zdGF0ZS5yZW5kZXJlZFNsaWRlcztcbiAgICAgIHZhciBuZXdSZW5kZXJlZFNsaWRlcyA9IHJlbmRlcmVkU2xpZGVzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIHNsaWRlSW5kZXggPSBfcmVmMy5zbGlkZUluZGV4LFxuICAgICAgICAgICAgZGF0YUluZGV4ID0gX3JlZjMuZGF0YUluZGV4O1xuICAgICAgICB2YXIgYWJzb2x1dGVTbGlkZUluZGV4ID0gTWF0aC5hYnMoc2xpZGVJbmRleCk7XG5cbiAgICAgICAgaWYgKGFic29sdXRlU2xpZGVJbmRleCA8PSBfdGhpcy5zbGlkZVBlclNpZGUgfHwgZGF0YUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld1JlbmRlcmVkU2xpZGVzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2FmZUdldFNsaWRlSW5mbyA9IGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICB2YXIgcG9zaXRpb25JbmRleCA9IHNsaWRlSW5kZXg7XG5cbiAgICAgIGlmIChwb3NpdGlvbkluZGV4ID4gX3RoaXMuc2xpZGVQZXJTaWRlKSB7XG4gICAgICAgIHBvc2l0aW9uSW5kZXggPSBfdGhpcy5zbGlkZVBlclNpZGU7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uSW5kZXggPCAtX3RoaXMuc2xpZGVQZXJTaWRlKSB7XG4gICAgICAgIHBvc2l0aW9uSW5kZXggPSAtX3RoaXMuc2xpZGVQZXJTaWRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuc2xpZGVJbmZvTWFwW3Bvc2l0aW9uSW5kZXhdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRJbnNlcnRpb25JbmZvID0gZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICB2YXIgbmV3QWRkZWRTbGlkZUluZGV4ID0gc3RlcHMgPiAwID8gX3RoaXMuc2xpZGVQZXJTaWRlIC0gc3RlcHMgKyAxIDogLV90aGlzLnNsaWRlUGVyU2lkZSAtIHN0ZXBzIC0gMTtcbiAgICAgIHZhciB0YXJnZXRTbGlkZUluZGV4ID0gc3RlcHMgPiAwID8gX3RoaXMuc2xpZGVQZXJTaWRlIDogLV90aGlzLnNsaWRlUGVyU2lkZTtcblxuICAgICAgdmFyIHJlcXVpcmVNb3JlU2xpZGUgPSBmdW5jdGlvbiByZXF1aXJlTW9yZVNsaWRlKGN1cnJlbnQsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gc3RlcHMgPiAwID8gY3VycmVudCA8PSB0YXJnZXQgOiBjdXJyZW50ID49IHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGRhdGVDb3VudCA9IHN0ZXBzID4gMCA/IDEgOiAtMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5ld0FkZGVkU2xpZGVJbmRleDogbmV3QWRkZWRTbGlkZUluZGV4LFxuICAgICAgICB0YXJnZXRTbGlkZUluZGV4OiB0YXJnZXRTbGlkZUluZGV4LFxuICAgICAgICByZXF1aXJlTW9yZVNsaWRlOiByZXF1aXJlTW9yZVNsaWRlLFxuICAgICAgICB1cGRhdGVDb3VudDogdXBkYXRlQ291bnRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLm1vdmVDYXJvdXNlbCA9IGZ1bmN0aW9uIChzdGVwcywgZGlzYWJsZVN3aXBlUmlnaHRTdGF0ZSkge1xuICAgICAgaWYgKGRpc2FibGVTd2lwZVJpZ2h0U3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBkaXNhYmxlU3dpcGVSaWdodFN0YXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJlZFNsaWRlcyA9IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzO1xuICAgICAgdmFyIG9uQWN0aXZlU2xpZGVDaGFuZ2UgPSBfdGhpcy5wcm9wcy5vbkFjdGl2ZVNsaWRlQ2hhbmdlO1xuICAgICAgdmFyIG5ld0NlbnRlckRhdGFJbmRleCA9IDA7XG4gICAgICB2YXIgbmV3U2xpZGVzID0gcmVuZGVyZWRTbGlkZXMubWFwKGZ1bmN0aW9uIChvbGRTbGlkZSkge1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IG9sZFNsaWRlLnNsaWRlSW5kZXgsXG4gICAgICAgICAgICBkYXRhSW5kZXggPSBvbGRTbGlkZS5kYXRhSW5kZXg7XG4gICAgICAgIGlmIChkYXRhSW5kZXggPT09IC0xKSByZXR1cm4gb2xkU2xpZGU7XG4gICAgICAgIGlmIChzbGlkZUluZGV4ID09PSAwKSBuZXdDZW50ZXJEYXRhSW5kZXggPSBfdGhpcy5tb2REYXRhUmFuZ2UoZGF0YUluZGV4ICsgc3RlcHMpO1xuICAgICAgICB2YXIgbmV3U2xpZGVJbmRleCA9IHNsaWRlSW5kZXggKyAtc3RlcHM7XG5cbiAgICAgICAgdmFyIHNsaWRlSW5mbyA9IF90aGlzLnNhZmVHZXRTbGlkZUluZm8obmV3U2xpZGVJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvbGRTbGlkZSwge1xuICAgICAgICAgIHNsaWRlSW5kZXg6IG5ld1NsaWRlSW5kZXgsXG4gICAgICAgICAgcG9zaXRpb246IHNsaWRlSW5mby5wb3NpdGlvbixcbiAgICAgICAgICBzY2FsZTogc2xpZGVJbmZvLnNjYWxlLFxuICAgICAgICAgIG9wYWNpdHk6IHNsaWRlSW5mby5vcGFjaXR5LFxuICAgICAgICAgIHpJbmRleDogX3RoaXMuZ2V0WkluZGV4KG5ld1NsaWRlSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdGVwcyAhPT0gMCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtYXhTbGlkZUluZGV4ID0gc3RlcHMgPiAwID8gX3RoaXMuc2xpZGVQZXJTaWRlIDogLV90aGlzLnNsaWRlUGVyU2lkZTtcbiAgICAgICAgICBfdGhpcy5hZGRlZFNsaWRlICs9IE1hdGguYWJzKHN0ZXBzKTtcblxuICAgICAgICAgIHZhciBpbnNlcnRpb25JbmZvID0gX3RoaXMuZ2V0SW5zZXJ0aW9uSW5mbyhzdGVwcyk7XG5cbiAgICAgICAgICB2YXIgbmV3QWRkZWRTbGlkZUluZGV4ID0gaW5zZXJ0aW9uSW5mby5uZXdBZGRlZFNsaWRlSW5kZXg7XG4gICAgICAgICAgdmFyIHJlcXVpcmVNb3JlU2xpZGUgPSBpbnNlcnRpb25JbmZvLnJlcXVpcmVNb3JlU2xpZGUsXG4gICAgICAgICAgICAgIHVwZGF0ZUNvdW50ID0gaW5zZXJ0aW9uSW5mby51cGRhdGVDb3VudCxcbiAgICAgICAgICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IGluc2VydGlvbkluZm8udGFyZ2V0U2xpZGVJbmRleDtcblxuICAgICAgICAgIHdoaWxlIChyZXF1aXJlTW9yZVNsaWRlKG5ld0FkZGVkU2xpZGVJbmRleCwgdGFyZ2V0U2xpZGVJbmRleCkpIHtcbiAgICAgICAgICAgIHZhciBzbGlkZUFscmVhZHlFeGlzdCA9IG5ld1NsaWRlcy5maW5kKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgICAgICB2YXIgc2xpZGVJbmRleCA9IF9yZWY0LnNsaWRlSW5kZXg7XG4gICAgICAgICAgICAgIHJldHVybiBzbGlkZUluZGV4ID09PSBuZXdBZGRlZFNsaWRlSW5kZXg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFzbGlkZUFscmVhZHlFeGlzdCkge1xuICAgICAgICAgICAgICB2YXIgaW5zZXJ0UG9zaXRpb24gPSBuZXdTbGlkZXMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciBzbGlkZUluZGV4ID0gX3JlZjUuc2xpZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4ID0gX3JlZjUuZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGlkZUluZGV4ID09PSBuZXdBZGRlZFNsaWRlSW5kZXggLSB1cGRhdGVDb3VudCAmJiBkYXRhSW5kZXggIT09IC0xO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIF90aGlzJHNsaWRlSW5mb01hcCRtYSA9IF90aGlzLnNsaWRlSW5mb01hcFttYXhTbGlkZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgIHNjYWxlID0gX3RoaXMkc2xpZGVJbmZvTWFwJG1hLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBfdGhpcyRzbGlkZUluZm9NYXAkbWEucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgdmFyIGluc2VydERhdGFJbmRleCA9IF90aGlzLm1vZERhdGFSYW5nZShuZXdTbGlkZXNbaW5zZXJ0UG9zaXRpb25dLmRhdGFJbmRleCArIHVwZGF0ZUNvdW50KTtcblxuICAgICAgICAgICAgICBfdGhpcy5rZXlDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgIHZhciB6SW5kZXggPSBfdGhpcy5nZXRaSW5kZXgobmV3QWRkZWRTbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0U2xpZGUgPSB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHpJbmRleDogekluZGV4IC0gX3RoaXMuYWRkZWRTbGlkZSxcbiAgICAgICAgICAgICAgICBzbGlkZUluZGV4OiBuZXdBZGRlZFNsaWRlSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBpbnNlcnREYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAga2V5OiBfdGhpcy5rZXlDb3VudFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBuZXdTbGlkZXMuc3BsaWNlKHN0ZXBzID4gMCA/IGluc2VydFBvc2l0aW9uICsgMSA6IGluc2VydFBvc2l0aW9uLCAwLCBpbnNlcnRTbGlkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0FkZGVkU2xpZGVJbmRleCArPSB1cGRhdGVDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwcyAhPT0gMCAmJiBvbkFjdGl2ZVNsaWRlQ2hhbmdlKSB7XG4gICAgICAgIG9uQWN0aXZlU2xpZGVDaGFuZ2UobmV3Q2VudGVyRGF0YUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN3aXBlU3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld1NsaWRlcyxcbiAgICAgICAgICBzd2lwUmlnaHQ6IGRpc2FibGVTd2lwZVJpZ2h0U3RhdGUgPyBmYWxzZSA6IHN0ZXBzIDwgMCA/IHRydWUgOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldFNsaWRlcygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRTbGlkZURPTUluZm8gPSBmdW5jdGlvbiAoc2xpZGVJbmRleCkge1xuICAgICAgdmFyIHNsaWRlV2lkdGggPSBfdGhpcy5wcm9wcy5zbGlkZVdpZHRoO1xuICAgICAgdmFyIGxpc3RSZWYgPSBfdGhpcy5saXN0UmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgc2xpZGVET00gPSBsaXN0UmVmLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJyZWFjdC1zdGFja2VkLWNlbnRlci1jYXJvdXNlbC1zbGlkZS1cIiArIHNsaWRlSW5kZXgpWzBdO1xuICAgICAgdmFyIHNsaWRlUmVjdCA9IHNsaWRlRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgX2xpc3RSZWYkZ2V0Qm91bmRpbmdDID0gbGlzdFJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBjYXJvdXNlbExlZnQgPSBfbGlzdFJlZiRnZXRCb3VuZGluZ0MubGVmdDtcblxuICAgICAgdmFyIHNjYWxlID0gc2xpZGVSZWN0LndpZHRoIC8gc2xpZGVXaWR0aDtcbiAgICAgIHZhciBhZGRpdGlvbmFsT2Zmc2V0ID0gc2xpZGVXaWR0aCAqIDAuNSAqICgxIC0gc2NhbGUpO1xuICAgICAgdmFyIHNsaWRlT2Zmc2V0TGVmdCA9IHNsaWRlUmVjdC5sZWZ0IC0gY2Fyb3VzZWxMZWZ0IC0gYWRkaXRpb25hbE9mZnNldDtcbiAgICAgIHZhciBzbGlkZUNlbnRlck9mZnNldCA9IHNsaWRlT2Zmc2V0TGVmdCAtIF90aGlzLmNlbnRlclBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBzbGlkZURPTTogc2xpZGVET00sXG4gICAgICAgIHNsaWRlQ2VudGVyT2Zmc2V0OiBzbGlkZUNlbnRlck9mZnNldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0U2xpZGVTY2FsZUFuZE9wYWNpdHkgPSBmdW5jdGlvbiAoY2VudGVyT2Zmc2V0KSB7XG4gICAgICB2YXIgdGFyZ2V0U2xpZGUgPSBfdGhpcy5zb3J0ZWRTbGlkZUluZm8uZmluZChmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gX3JlZjYucG9zaXRpb247XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocG9zaXRpb24pID49IGNlbnRlck9mZnNldDtcbiAgICAgIH0pIHx8IF90aGlzLnNvcnRlZFNsaWRlSW5mb1tfdGhpcy5zb3J0ZWRTbGlkZUluZm8ubGVuZ3RoIC0gMV07XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldFNsaWRlLnBvc2l0aW9uLFxuICAgICAgICAgIHNsaWRlSW5kZXggPSB0YXJnZXRTbGlkZS5zbGlkZUluZGV4LFxuICAgICAgICAgIHNjYWxlID0gdGFyZ2V0U2xpZGUuc2NhbGUsXG4gICAgICAgICAgbWF4VHJhbnNmb3JtRGlzdGFuY2UgPSB0YXJnZXRTbGlkZS5tYXhUcmFuc2Zvcm1EaXN0YW5jZSxcbiAgICAgICAgICBtYXhUcmFuc2Zvcm1TY2FsZSA9IHRhcmdldFNsaWRlLm1heFRyYW5zZm9ybVNjYWxlLFxuICAgICAgICAgIG1heFRyYW5zZm9ybU9wYWNpdHkgPSB0YXJnZXRTbGlkZS5tYXhUcmFuc2Zvcm1PcGFjaXR5LFxuICAgICAgICAgIG9wYWNpdHkgPSB0YXJnZXRTbGlkZS5vcGFjaXR5O1xuICAgICAgdmFyIG9mZnNldCA9IE1hdGguY2VpbChwb3NpdGlvbikgLSBjZW50ZXJPZmZzZXQ7XG4gICAgICB2YXIgb2Zmc2V0UGVyY2VudGFnZSA9IG1heFRyYW5zZm9ybURpc3RhbmNlLmxlZnQgPT09IDAgPyAwIDogb2Zmc2V0IC8gbWF4VHJhbnNmb3JtRGlzdGFuY2UubGVmdCAqIChzbGlkZUluZGV4IDw9IDAgPyAtMSA6IDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlICsgbWF4VHJhbnNmb3JtU2NhbGUubGVmdCAqIG9mZnNldFBlcmNlbnRhZ2UsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHkgKyBtYXhUcmFuc2Zvcm1PcGFjaXR5LmxlZnQgKiBvZmZzZXRQZXJjZW50YWdlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5jZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiAoc2xpZGVJbmRleCkge1xuICAgICAgdmFyIF90aGlzJGdldFNsaWRlRE9NSW5mbzIgPSBfdGhpcy5nZXRTbGlkZURPTUluZm8oc2xpZGVJbmRleCksXG4gICAgICAgICAgc2xpZGVDZW50ZXJPZmZzZXQgPSBfdGhpcyRnZXRTbGlkZURPTUluZm8yLnNsaWRlQ2VudGVyT2Zmc2V0O1xuXG4gICAgICByZXR1cm4gTWF0aC5hYnMoX3RoaXMuc2xpZGVJbmZvTWFwWzBdLnBvc2l0aW9uIC0gc2xpZGVDZW50ZXJPZmZzZXQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblN3aXBlU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9uQWN0aXZlU2xpZGVDaGFuZ2UgPSBfdGhpcyRwcm9wczQub25BY3RpdmVTbGlkZUNoYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3dpcGUgPSBfdGhpcyRwcm9wczQuZGlzYWJsZVN3aXBlO1xuICAgICAgaWYgKGRpc2FibGVTd2lwZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgaW5pdGFsU3dpcGVYID0gX3RoaXMuZ2V0U3dpcGVYKGUpO1xuXG4gICAgICB2YXIgcmVuZGVyZWRTbGlkZXMgPSBfdGhpcy5zdGF0ZS5yZW5kZXJlZFNsaWRlcztcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5jbGVhclNsaWRlVGltZW91dCk7XG4gICAgICB2YXIgc2hpZnREaXJlY3Rpb24gPSAwO1xuICAgICAgdmFyIGNlbnRlckRhdGFJbmRleCA9IDA7XG4gICAgICBpZiAoX3RoaXMuY2VudGVyT2Zmc2V0KC0xKSA8IF90aGlzLmNlbnRlck9mZnNldCgwKSkgc2hpZnREaXJlY3Rpb24gPSAxO2Vsc2UgaWYgKF90aGlzLmNlbnRlck9mZnNldCgxKSA8IF90aGlzLmNlbnRlck9mZnNldCgwKSkgc2hpZnREaXJlY3Rpb24gPSAtMTtcbiAgICAgIHZhciBuZXdSZW5kZXJlZFNsaWRlcyA9IFtdO1xuICAgICAgdmFyIHN3aXBlUG9zaXRpb25JbmZvID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocmVuZGVyZWRTbGlkZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICB2YXIgc2xpZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIHNsaWRlSW5kZXggPSBzbGlkZS5zbGlkZUluZGV4LFxuICAgICAgICAgICAgZGF0YUluZGV4ID0gc2xpZGUuZGF0YUluZGV4O1xuXG4gICAgICAgIGlmIChkYXRhSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgbmV3UmVuZGVyZWRTbGlkZXMucHVzaChzbGlkZSk7XG4gICAgICAgICAgc3dpcGVQb3NpdGlvbkluZm8ucHVzaCh7XG4gICAgICAgICAgICBzbGlkZUluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgICAgICAgbWF4TGVmdDogMCxcbiAgICAgICAgICAgIG1heFJpZ2h0OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3U2xpZGVJbmRleCA9IHNsaWRlSW5kZXggKyBzaGlmdERpcmVjdGlvbjtcbiAgICAgICAgaWYgKE1hdGguYWJzKG5ld1NsaWRlSW5kZXgpID4gX3RoaXMuc2xpZGVQZXJTaWRlKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG5ld1NsaWRlSW5kZXggPT09IDApIGNlbnRlckRhdGFJbmRleCA9IGRhdGFJbmRleDtcblxuICAgICAgICB2YXIgX3RoaXMkZ2V0U2xpZGVET01JbmZvMyA9IF90aGlzLmdldFNsaWRlRE9NSW5mbyhzbGlkZUluZGV4KSxcbiAgICAgICAgICAgIHNsaWRlQ2VudGVyT2Zmc2V0ID0gX3RoaXMkZ2V0U2xpZGVET01JbmZvMy5zbGlkZUNlbnRlck9mZnNldCxcbiAgICAgICAgICAgIHNjYWxlID0gX3RoaXMkZ2V0U2xpZGVET01JbmZvMy5zY2FsZTtcblxuICAgICAgICB2YXIgX3RoaXMkZ2V0U2xpZGVTY2FsZUFuID0gX3RoaXMuZ2V0U2xpZGVTY2FsZUFuZE9wYWNpdHkoc2xpZGVDZW50ZXJPZmZzZXQpLFxuICAgICAgICAgICAgb3BhY2l0eSA9IF90aGlzJGdldFNsaWRlU2NhbGVBbi5vcGFjaXR5O1xuXG4gICAgICAgIHZhciBfdGhpcyRzYWZlR2V0U2xpZGVJbmYgPSBfdGhpcy5zYWZlR2V0U2xpZGVJbmZvKG5ld1NsaWRlSW5kZXgpLFxuICAgICAgICAgICAgbWF4VHJhbnNmb3JtRGlzdGFuY2UgPSBfdGhpcyRzYWZlR2V0U2xpZGVJbmYubWF4VHJhbnNmb3JtRGlzdGFuY2UsXG4gICAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzJHNhZmVHZXRTbGlkZUluZi5wb3NpdGlvbjtcblxuICAgICAgICBzd2lwZVBvc2l0aW9uSW5mby5wdXNoKHtcbiAgICAgICAgICBzbGlkZUluZGV4OiBuZXdTbGlkZUluZGV4LFxuICAgICAgICAgIG1heExlZnQ6IHNsaWRlQ2VudGVyT2Zmc2V0IC0gcG9zaXRpb24gKyBtYXhUcmFuc2Zvcm1EaXN0YW5jZS5sZWZ0LFxuICAgICAgICAgIG1heFJpZ2h0OiBwb3NpdGlvbiArIG1heFRyYW5zZm9ybURpc3RhbmNlLnJpZ2h0IC0gc2xpZGVDZW50ZXJPZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld1JlbmRlcmVkU2xpZGVzLnB1c2goX2V4dGVuZHMoe30sIHNsaWRlLCB7XG4gICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgcG9zaXRpb246IHNsaWRlQ2VudGVyT2Zmc2V0LFxuICAgICAgICAgIHNsaWRlSW5kZXg6IG5ld1NsaWRlSW5kZXgsXG4gICAgICAgICAgekluZGV4OiBfdGhpcy5nZXRaSW5kZXgobmV3U2xpZGVJbmRleClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25BY3RpdmVTbGlkZUNoYW5nZSAmJiBzaGlmdERpcmVjdGlvbiAhPT0gMCkge1xuICAgICAgICBvbkFjdGl2ZVNsaWRlQ2hhbmdlKGNlbnRlckRhdGFJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3dpcGVTdGFydGVkOiB0cnVlLFxuICAgICAgICBpbml0YWxTd2lwZVg6IGluaXRhbFN3aXBlWCxcbiAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld1JlbmRlcmVkU2xpZGVzLFxuICAgICAgICBwcmV2UmVuZGVyZWRTbGlkZXM6IFtdLmNvbmNhdChuZXdSZW5kZXJlZFNsaWRlcyksXG4gICAgICAgIHN3aXBlUG9zaXRpb25JbmZvOiBzd2lwZVBvc2l0aW9uSW5mb1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uU3dpcGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHN3aXBlU3RhcnRlZCA9IF90aGlzLnN0YXRlLnN3aXBlU3RhcnRlZDtcblxuICAgICAgaWYgKCFzd2lwZVN0YXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBpbml0YWxTd2lwZVggPSBfdGhpcyRzdGF0ZS5pbml0YWxTd2lwZVgsXG4gICAgICAgICAgcHJldlJlbmRlcmVkU2xpZGVzID0gX3RoaXMkc3RhdGUucHJldlJlbmRlcmVkU2xpZGVzLFxuICAgICAgICAgIHN3aXBlUG9zaXRpb25JbmZvID0gX3RoaXMkc3RhdGUuc3dpcGVQb3NpdGlvbkluZm87XG4gICAgICB2YXIgc2xpZGVXaWR0aCA9IF90aGlzLnByb3BzLnNsaWRlV2lkdGg7XG4gICAgICB2YXIgdGVtcFNoaWZ0ID0gZmFsc2U7XG5cbiAgICAgIHZhciBjdXJyZW50U3dpcGVYID0gX3RoaXMuZ2V0U3dpcGVYKGUpO1xuXG4gICAgICB2YXIgc3dpcGVEaXN0YW5jZSA9IGluaXRhbFN3aXBlWCAtIGN1cnJlbnRTd2lwZVg7XG4gICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhzd2lwZURpc3RhbmNlKTtcbiAgICAgIHZhciBzd2lwZUxlZnQgPSBzd2lwZURpc3RhbmNlID4gMDtcbiAgICAgIHZhciB0cmFuc2Zvcm1GYWN0b3IgPSAxMCAvIHNsaWRlV2lkdGggKiBkZWx0YTtcbiAgICAgIHZhciB0cmFuc2Zvcm1QZXJjZW50YWdlID0gMSAtIE1hdGgucG93KDEgLSAoX3RoaXMucHJvcHMuc3dpcGVTcGVlZCB8fCAwLjUpLCB0cmFuc2Zvcm1GYWN0b3IpO1xuICAgICAgdmFyIG5ld1JlbmRlcmVkU2xpZGVzID0gcHJldlJlbmRlcmVkU2xpZGVzLm1hcChmdW5jdGlvbiAoc2xpZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHNsaWRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgc2xpZGVJbmRleCA9IHNsaWRlLnNsaWRlSW5kZXgsXG4gICAgICAgICAgICBkYXRhSW5kZXggPSBzbGlkZS5kYXRhSW5kZXg7XG4gICAgICAgIGlmIChkYXRhSW5kZXggPT09IC0xKSByZXR1cm4gc2xpZGU7XG4gICAgICAgIHZhciBtYXhEZWx0YVggPSBzd2lwZVBvc2l0aW9uSW5mb1tpbmRleF1bc3dpcGVMZWZ0ID8gJ21heExlZnQnIDogJ21heFJpZ2h0J107XG4gICAgICAgIHZhciB0YXJnZXRQb3NpdGlvbiA9IHBvc2l0aW9uICsgKHN3aXBlTGVmdCA/IC0xIDogMSkgKiBtYXhEZWx0YVggKiB0cmFuc2Zvcm1QZXJjZW50YWdlO1xuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTbGlkZVNjYWxlQW4yID0gX3RoaXMuZ2V0U2xpZGVTY2FsZUFuZE9wYWNpdHkodGFyZ2V0UG9zaXRpb24pLFxuICAgICAgICAgICAgc2NhbGUgPSBfdGhpcyRnZXRTbGlkZVNjYWxlQW4yLnNjYWxlLFxuICAgICAgICAgICAgb3BhY2l0eSA9IF90aGlzJGdldFNsaWRlU2NhbGVBbjIub3BhY2l0eTtcblxuICAgICAgICB2YXIgekluZGV4ID0gc2xpZGUuekluZGV4O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzbGlkZUluZGV4KSA9PT0gMSkge1xuICAgICAgICAgIGlmIChfdGhpcy5jZW50ZXJPZmZzZXQoc2xpZGVJbmRleCkgPCBfdGhpcy5jZW50ZXJPZmZzZXQoMCkpIHtcbiAgICAgICAgICAgIHpJbmRleCA9IF90aGlzLm1heFpJbmRleDtcbiAgICAgICAgICAgIHRlbXBTaGlmdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzbGlkZSwge1xuICAgICAgICAgIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICB6SW5kZXg6IHpJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHJlbmRlcmVkU2xpZGVzOiBuZXdSZW5kZXJlZFNsaWRlcyxcbiAgICAgICAgdGVtcFNoaWZ0OiB0ZW1wU2hpZnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZXNldFNsaWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW5kZXJlZFNsaWRlcyA9IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzO1xuICAgICAgdmFyIG5ld0RlZmF1bHQgPSByZW5kZXJlZFNsaWRlcy5tYXAoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHZhciBfdGhpcyRzYWZlR2V0U2xpZGVJbmYyID0gX3RoaXMuc2FmZUdldFNsaWRlSW5mbyhzbGlkZS5zbGlkZUluZGV4KSxcbiAgICAgICAgICAgIG9wYWNpdHkgPSBfdGhpcyRzYWZlR2V0U2xpZGVJbmYyLm9wYWNpdHksXG4gICAgICAgICAgICBzY2FsZSA9IF90aGlzJHNhZmVHZXRTbGlkZUluZjIuc2NhbGUsXG4gICAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzJHNhZmVHZXRTbGlkZUluZjIucG9zaXRpb247XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzbGlkZSwge1xuICAgICAgICAgIHpJbmRleDogX3RoaXMuZ2V0WkluZGV4KHNsaWRlLnNsaWRlSW5kZXgpLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld0RlZmF1bHQsXG4gICAgICAgICAgc3dpcFJpZ2h0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSwgX3RoaXMuZGVib3VuY2VkQ2xlYXJJbnZpc2libGVTbGlkZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uU3dpcGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3dpcGVTdGFydGVkID0gX3RoaXMuc3RhdGUuc3dpcGVTdGFydGVkO1xuICAgICAgaWYgKCFzd2lwZVN0YXJ0ZWQpIHJldHVybjtcbiAgICAgIHZhciByZW5kZXJlZFNsaWRlcyA9IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzO1xuICAgICAgdmFyIG5ld0NlbnRlclNsaWRlID0gcmVuZGVyZWRTbGlkZXMuZmluZChmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgdmFyIHpJbmRleCA9IF9yZWY3LnpJbmRleDtcbiAgICAgICAgcmV0dXJuIHpJbmRleCA9PT0gX3RoaXMubWF4WkluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLm1vdmVDYXJvdXNlbCgobmV3Q2VudGVyU2xpZGUgPT09IG51bGwgfHwgbmV3Q2VudGVyU2xpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0NlbnRlclNsaWRlLnNsaWRlSW5kZXgpIHx8IDApO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRlbXBTaGlmdDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5nb05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5tb3ZlQ2Fyb3VzZWwoMSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdvQmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm1vdmVDYXJvdXNlbCgtMSk7XG4gICAgfTtcblxuICAgIF90aGlzLnN3aXBlVG8gPSBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgIF90aGlzLm1vdmVDYXJvdXNlbChzdGVwcyk7XG4gICAgfTtcblxuICAgIHZhciBfdGhpcyRpbml0aWFsaXplUHJvcGUgPSBfdGhpcy5pbml0aWFsaXplUHJvcGVydGllcyh0cnVlKSxcbiAgICAgICAgcmVuZGVyZWRTbGlkZXMgPSBfdGhpcyRpbml0aWFsaXplUHJvcGUucmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHNsaWRlSW5mb01hcCA9IF90aGlzJGluaXRpYWxpemVQcm9wZS5zbGlkZUluZm9NYXAsXG4gICAgICAgIHNsaWRlUGVyU2lkZSA9IF90aGlzJGluaXRpYWxpemVQcm9wZS5zbGlkZVBlclNpZGUsXG4gICAgICAgIHNvcnRlZFNsaWRlSW5mbyA9IF90aGlzJGluaXRpYWxpemVQcm9wZS5zb3J0ZWRTbGlkZUluZm8sXG4gICAgICAgIGNlbnRlclBvc2l0aW9uID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlLmNlbnRlclBvc2l0aW9uLFxuICAgICAgICByZW5kZXJlZFNsaWRlUGVyU2lkZSA9IF90aGlzJGluaXRpYWxpemVQcm9wZS5yZW5kZXJlZFNsaWRlUGVyU2lkZTtcblxuICAgIHZhciBvbkFjdGl2ZVNsaWRlQ2hhbmdlID0gX3RoaXMucHJvcHMub25BY3RpdmVTbGlkZUNoYW5nZTtcbiAgICBfdGhpcy5zbGlkZUluZm9NYXAgPSBzbGlkZUluZm9NYXA7XG4gICAgX3RoaXMuc29ydGVkU2xpZGVJbmZvID0gc29ydGVkU2xpZGVJbmZvO1xuICAgIF90aGlzLnNsaWRlUGVyU2lkZSA9IHNsaWRlUGVyU2lkZTtcbiAgICBfdGhpcy5oZWlnaHQgPSBfdGhpcy5wcm9wcy5oZWlnaHQgfHwgMDtcbiAgICBfdGhpcy5saXN0UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuY2xlYXJTbGlkZVRpbWVvdXQgPSBudWxsO1xuICAgIF90aGlzLmtleUNvdW50ID0gcHJvcHMuZGF0YS5sZW5ndGg7XG4gICAgX3RoaXMuYWRkZWRTbGlkZSA9IDA7XG4gICAgX3RoaXMuY2VudGVyUG9zaXRpb24gPSBjZW50ZXJQb3NpdGlvbjtcbiAgICBfdGhpcy5tYXhaSW5kZXggPSAxMDA7XG4gICAgX3RoaXMucmVuZGVyZWRTbGlkZVBlclNpZGUgPSByZW5kZXJlZFNsaWRlUGVyU2lkZTtcblxuICAgIGlmIChvbkFjdGl2ZVNsaWRlQ2hhbmdlKSB7XG4gICAgICBvbkFjdGl2ZVNsaWRlQ2hhbmdlKDApO1xuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaW5pdGFsU3dpcGVYOiAwLFxuICAgICAgc3dpcGVTdGFydGVkOiBmYWxzZSxcbiAgICAgIHJlbmRlcmVkU2xpZGVzOiByZW5kZXJlZFNsaWRlcyxcbiAgICAgIHByZXZSZW5kZXJlZFNsaWRlczogW10uY29uY2F0KHJlbmRlcmVkU2xpZGVzKSxcbiAgICAgIHN3aXBlUG9zaXRpb25JbmZvOiBbXSxcbiAgICAgIHN3aXBSaWdodDogZmFsc2UsXG4gICAgICB0ZW1wU2hpZnQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RhY2tlZENhcm91c2VsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsZWFyU2xpZGVUaW1lb3V0KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICghc2hvdWxkUmVjYWNsY3VsYXRlKHRoaXMucHJvcHMsIHByZXZQcm9wcykpIHJldHVybjtcblxuICAgIHZhciBfdGhpcyRpbml0aWFsaXplUHJvcGUyID0gdGhpcy5pbml0aWFsaXplUHJvcGVydGllcyh0aGlzLnByb3BzLm1heFZpc2libGVTbGlkZSAhPT0gcHJldlByb3BzLm1heFZpc2libGVTbGlkZSksXG4gICAgICAgIHNsaWRlSW5mb01hcCA9IF90aGlzJGluaXRpYWxpemVQcm9wZTIuc2xpZGVJbmZvTWFwLFxuICAgICAgICBzbGlkZVBlclNpZGUgPSBfdGhpcyRpbml0aWFsaXplUHJvcGUyLnNsaWRlUGVyU2lkZSxcbiAgICAgICAgbmV3UmVuZGVyZWRTbGlkZXMgPSBfdGhpcyRpbml0aWFsaXplUHJvcGUyLm5ld1JlbmRlcmVkU2xpZGVzLFxuICAgICAgICBzb3J0ZWRTbGlkZUluZm8gPSBfdGhpcyRpbml0aWFsaXplUHJvcGUyLnNvcnRlZFNsaWRlSW5mbyxcbiAgICAgICAgY2VudGVyUG9zaXRpb24gPSBfdGhpcyRpbml0aWFsaXplUHJvcGUyLmNlbnRlclBvc2l0aW9uO1xuXG4gICAgdGhpcy5zbGlkZUluZm9NYXAgPSBzbGlkZUluZm9NYXA7XG4gICAgdGhpcy5zb3J0ZWRTbGlkZUluZm8gPSBzb3J0ZWRTbGlkZUluZm87XG4gICAgdGhpcy5zbGlkZVBlclNpZGUgPSBzbGlkZVBlclNpZGU7XG4gICAgdGhpcy5jZW50ZXJQb3NpdGlvbiA9IGNlbnRlclBvc2l0aW9uO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdGFsU3dpcGVYOiAwLFxuICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHByZXZSZW5kZXJlZFNsaWRlczogW10uY29uY2F0KG5ld1JlbmRlcmVkU2xpZGVzKSxcbiAgICAgICAgc3dpcFJpZ2h0OiBmYWxzZVxuICAgICAgfTtcbiAgICB9LCB0aGlzLnVwZGF0ZUhlaWdodCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFN3aXBlWCA9IGZ1bmN0aW9uIGdldFN3aXBlWChlKSB7XG4gICAgaWYgKGUudHlwZVswXSA9PT0gJ20nKSByZXR1cm4gZS5jbGllbnRYO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfZSR0b3VjaGVzJCwgX2UkY2hhbmdlZFRvdWNoZXMkO1xuXG4gICAgICByZXR1cm4gKChfZSR0b3VjaGVzJCA9IGUudG91Y2hlc1swXSkgPT09IG51bGwgfHwgX2UkdG91Y2hlcyQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJHRvdWNoZXMkLmNsaWVudFgpIHx8ICgoX2UkY2hhbmdlZFRvdWNoZXMkID0gZS5jaGFuZ2VkVG91Y2hlc1swXSkgPT09IG51bGwgfHwgX2UkY2hhbmdlZFRvdWNoZXMkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZSRjaGFuZ2VkVG91Y2hlcyQuY2xpZW50WCk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggZ2V0dGluZyBtb3VzZSBwb3NpdGlvbicpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHN3aXBlU3RhcnRlZCA9IF90aGlzJHN0YXRlMi5zd2lwZVN0YXJ0ZWQsXG4gICAgICAgIHJlbmRlcmVkU2xpZGVzID0gX3RoaXMkc3RhdGUyLnJlbmRlcmVkU2xpZGVzLFxuICAgICAgICBzd2lwUmlnaHQgPSBfdGhpcyRzdGF0ZTIuc3dpcFJpZ2h0LFxuICAgICAgICB0ZW1wU2hpZnQgPSBfdGhpcyRzdGF0ZTIudGVtcFNoaWZ0O1xuICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wczUuc2xpZGVDb21wb25lbnQsXG4gICAgICAgIF90aGlzJHByb3BzNSR0cmFuc2l0aSA9IF90aGlzJHByb3BzNS50cmFuc2l0aW9uVGltZSxcbiAgICAgICAgdHJhbnNpdGlvblRpbWUgPSBfdGhpcyRwcm9wczUkdHJhbnNpdGkgPT09IHZvaWQgMCA/IFN0YWNrZWRDYXJvdXNlbC5kZWZhdWx0VHJhbnNpdGlvblRpbWUgOiBfdGhpcyRwcm9wczUkdHJhbnNpdGksXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNS5jbGFzc05hbWUsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczUuZGF0YSxcbiAgICAgICAgc2xpZGVXaWR0aCA9IF90aGlzJHByb3BzNS5zbGlkZVdpZHRoLFxuICAgICAgICBjdXN0b21UcmFuc2l0aW9uID0gX3RoaXMkcHJvcHM1LmN1c3RvbVRyYW5zaXRpb24sXG4gICAgICAgIGNhcm91c2VsV2lkdGggPSBfdGhpcyRwcm9wczUuY2Fyb3VzZWxXaWR0aCxcbiAgICAgICAgdXNlR3JhYkN1cnNvciA9IF90aGlzJHByb3BzNS51c2VHcmFiQ3Vyc29yLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0O1xuICAgIHZhciBjdXJzb3IgPSB1c2VHcmFiQ3Vyc29yICYmIChzd2lwZVN0YXJ0ZWQgPyAnZ3JhYmJpbmcnIDogJ2dyYWInKSB8fCAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LXN0YWNrZWQtY2VudGVyLWNhcm91c2VsIFwiICsgKGNsYXNzTmFtZSB8fCAnJyksXG4gICAgICBvbk1vdXNlRG93bjogdGhpcy5vblN3aXBlU3RhcnQsXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Td2lwZUVuZCxcbiAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLm9uU3dpcGUsXG4gICAgICBvbk1vdXNlTGVhdmU6IHRoaXMub25Td2lwZUVuZCxcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5vblN3aXBlU3RhcnQsXG4gICAgICBvblRvdWNoTW92ZTogdGhpcy5vblN3aXBlLFxuICAgICAgb25Ub3VjaEVuZDogdGhpcy5vblN3aXBlRW5kLFxuICAgICAgcmVmOiB0aGlzLmxpc3RSZWYsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogY2Fyb3VzZWxXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgdGhpcy5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGN1cnNvcjogY3Vyc29yXG4gICAgICB9XG4gICAgfSwgcmVuZGVyZWRTbGlkZXMubWFwKGZ1bmN0aW9uIChfcmVmOCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSBfcmVmOC5vcGFjaXR5LFxuICAgICAgICAgIHNsaWRlSW5kZXggPSBfcmVmOC5zbGlkZUluZGV4LFxuICAgICAgICAgIGRhdGFJbmRleCA9IF9yZWY4LmRhdGFJbmRleCxcbiAgICAgICAgICBwb3NpdGlvbiA9IF9yZWY4LnBvc2l0aW9uLFxuICAgICAgICAgIHNjYWxlID0gX3JlZjguc2NhbGUsXG4gICAgICAgICAga2V5ID0gX3JlZjgua2V5LFxuICAgICAgICAgIHpJbmRleCA9IF9yZWY4LnpJbmRleDtcbiAgICAgIHZhciBJRCA9IGRhdGFJbmRleCA9PT0gLTEgPyBcImhpZGRlbi1cIiArIGtleSA6IHNsaWRlSW5kZXg7XG4gICAgICB2YXIgekR1cmF0aW9uID0gdHJhbnNpdGlvblRpbWUgKiAoc3dpcFJpZ2h0ID8gMC42IDogMSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHN3aXBlU3RhcnRlZCA/ICdub25lJyA6IGN1c3RvbVRyYW5zaXRpb24gfHwgXCJhbGwgXCIgKyB0cmFuc2l0aW9uVGltZSArIFwibXMgZWFzZSwgei1pbmRleCBcIiArIHpEdXJhdGlvbiArIFwibXMgZWFzZVwiO1xuICAgICAgdmFyIGlzQ2VudGVyU2xpZGUgPSB0ZW1wU2hpZnQgPyB6SW5kZXggPT09IF90aGlzMi5tYXhaSW5kZXggOiBzbGlkZUluZGV4ID09PSAwO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LXN0YWNrZWQtY2VudGVyLWNhcm91c2VsLXNsaWRlLVwiICsgSUQsXG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIGxlZnQ6IFwiY2FsYyg1MCUgLSBcIiArIHNsaWRlV2lkdGggLyAyICsgXCJweClcIixcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWChcIiArIHBvc2l0aW9uICsgXCJweCkgc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiLFxuICAgICAgICAgIHdpZHRoOiBzbGlkZVdpZHRoLFxuICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICB6SW5kZXg6IHpJbmRleFxuICAgICAgICB9XG4gICAgICB9LCBkYXRhSW5kZXggIT09IC0xICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBzbGlkZUluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgICBpc0NlbnRlclNsaWRlOiBpc0NlbnRlclNsaWRlLFxuICAgICAgICBzd2lwZVRvOiBfdGhpczIuc3dpcGVUb1xuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhY2tlZENhcm91c2VsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblN0YWNrZWRDYXJvdXNlbC5kZWZhdWx0U2NhbGVGYWN0b3IgPSAwLjg1O1xuU3RhY2tlZENhcm91c2VsLmRlZmF1bHRUcmFuc2l0aW9uVGltZSA9IDQ1MDtcblxuZnVuY3Rpb24gc2hvdWxkUmVjYWNsY3VsYXRlKHByb3AxLCBwcm9wMikge1xuICB2YXIgX3Byb3AxJGN1c3RvbVNjYWxlcywgX3Byb3AyJGN1c3RvbVNjYWxlcztcblxuICBpZiAocHJvcDEuc2xpZGVXaWR0aCAhPT0gcHJvcDIuc2xpZGVXaWR0aCB8fCBwcm9wMS5jYXJvdXNlbFdpZHRoICE9PSBwcm9wMi5jYXJvdXNlbFdpZHRoIHx8IHByb3AxLm1heFZpc2libGVTbGlkZSAhPT0gcHJvcDIubWF4VmlzaWJsZVNsaWRlIHx8IHByb3AxLmN1cnJlbnRWaXNpYmxlU2xpZGUgIT09IHByb3AyLmN1cnJlbnRWaXNpYmxlU2xpZGUgfHwgcHJvcDEuZmFkZURpc3RhbmNlICE9PSBwcm9wMi5mYWRlRGlzdGFuY2UgfHwgKChfcHJvcDEkY3VzdG9tU2NhbGVzID0gcHJvcDEuY3VzdG9tU2NhbGVzKSA9PT0gbnVsbCB8fCBfcHJvcDEkY3VzdG9tU2NhbGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcDEkY3VzdG9tU2NhbGVzLmpvaW4oJycpKSAhPT0gKChfcHJvcDIkY3VzdG9tU2NhbGVzID0gcHJvcDIuY3VzdG9tU2NhbGVzKSA9PT0gbnVsbCB8fCBfcHJvcDIkY3VzdG9tU2NhbGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcDIkY3VzdG9tU2NhbGVzLmpvaW4oJycpKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gUmVzcG9uc2l2ZUNvbnRhaW5lcihwcm9wcykge1xuICB2YXIgcmVuZGVyID0gcHJvcHMucmVuZGVyLFxuICAgICAgY2Fyb3VzZWxSZWYgPSBwcm9wcy5jYXJvdXNlbFJlZjtcblxuICB2YXIgX3VzZVJlc2l6ZURldGVjdG9yID0gdXNlUmVzaXplRGV0ZWN0b3IoKSxcbiAgICAgIHdpZHRoID0gX3VzZVJlc2l6ZURldGVjdG9yLndpZHRoLFxuICAgICAgcmVmID0gX3VzZVJlc2l6ZURldGVjdG9yLnJlZjtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiByZWYsXG4gICAgY2xhc3NOYW1lOiAnc3RhY2tlZC1jYXJvdXNlbC1yZXNwb25zaXZlLWNvbnRhaW5lcicsXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9XG4gIH0sIHdpZHRoICYmIHJlbmRlcih3aWR0aCwgY2Fyb3VzZWxSZWYpKTtcbn1cblxuZXhwb3J0IHsgUmVzcG9uc2l2ZUNvbnRhaW5lciwgU3RhY2tlZENhcm91c2VsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-stacked-center-carousel/dist/index.modern.js\n");

/***/ })

};
;